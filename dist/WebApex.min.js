/*! For license information please see WebApex.min.js.LICENSE.txt */
(()=>{"use strict";var t={d:(e,r)=>{for(var a in r)t.o(r,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:r[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>a});class r{#t;constructor(){"undefined"==typeof window?this.#e():(this.#t=window.crypto,this.#t.CryptoKey=window.CryptoKey)}#e=async()=>{this.#t=await Object.getPrototypeOf((async function(){})).constructor('\n      return await import( "crypto" ).then((m) => {return m.default.webcrypto});\n')()};#r=async t=>{await new Promise(((e,r)=>{setTimeout((()=>e(!0)),t)}))};base64ToArray(t){return Uint8Array.from(atob(t),(t=>t.charCodeAt(0)))}arrayToBase64(t){return btoa(String.fromCharCode(...t))}HMAC=async(t,e)=>{await this.#r(0);let r=new TextEncoder("utf-8"),a=r.encode(t),i=r.encode(e),s=await this.#t.subtle.importKey("raw",a,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"]),n=await this.#t.subtle.sign("HMAC",s,i),o=new Uint8Array(n);return Array.prototype.map.call(o,(t=>("00"+t.toString(16)).slice(-2))).join("")};HASH=async(t,e,r)=>{let a,i=await this.#t.subtle.digest(t,(new TextEncoder).encode(e)),s=new Uint8Array(i);if(r){a=new Uint8Array(r,0),Math.min(r,s.length);let t=Math.max(r,s.length);for(var n=0;n<t;n++)a[n%r]=a[n%r]^s[n%s.length]}else a=s;return this.arrayToBase64(new Uint8Array(a))};AESMakeKey=async(t=!0)=>{await this.#r(0);let e=await this.#t.subtle.generateKey({name:"AES-GCM",length:256},t,["encrypt","decrypt"]);if(t){let t=await this.#t.subtle.exportKey("raw",e);return this.arrayToBase64(new Uint8Array(t))}return e};AESImportKey=async(t,e=!0)=>(await this.#r(0),t instanceof this.#t.CryptoKey?t:await this.#t.subtle.importKey("raw",this.base64ToArray(t).buffer,"AES-GCM",e,["encrypt","decrypt"]));async AESEncrypt(t,e,r=!1){await this.#r(0);let a,i=await this.AESImportKey(t);a=r?this.base64ToArray(r):this.#t.getRandomValues(new Uint8Array(16));let s=await this.#t.subtle.encrypt({name:"AES-GCM",iv:a},i,this.base64ToArray(e));return{ciphertext:this.arrayToBase64(new Uint8Array(s)),iv:this.arrayToBase64(a)}}async AESDecrypt(t,e,r,a=!1){await this.#r(0);let i,s=await this.AESImportKey(t),n=this.base64ToArray(e),o=this.base64ToArray(r);return i=await this.#t.subtle.decrypt({name:"AES-GCM",iv:n},s,o),a?(i=new Uint8Array(i),i=(new TextDecoder).decode(i),i):i}EcMakeCryptKeys=async(t=!0)=>{await this.#r(0);let e,r=await this.#t.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},t,["deriveKey","deriveBits"]);return e=t?await Promise.all([this.#t.subtle.exportKey("spki",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("pkcs8",r.privateKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("jwk",r.publicKey).then((t=>t)),this.#t.subtle.exportKey("jwk",r.privateKey).then((t=>t)),this.#t.subtle.exportKey("raw",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("raw",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t).slice(1,1e3))))]):await Promise.all([this.#t.subtle.exportKey("spki",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),new Promise(((t,e)=>t(r.privateKey))),this.#t.subtle.exportKey("raw",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("raw",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t).slice(1,1e3))))]),t?{publicKey:e[0],privateKey:e[1],jwkPublicKey:e[2],jwkPrivateKey:e[3],rawPublicKey:e[4],rawPublicKeyLite:e[5]}:{publicKey:e[0],privateKey:e[1],rawPublicKey:e[2],rawPublicKeyLite:e[3]}};EcEncrypt=async(t,e,r)=>{await this.#r(0);let a=await this.EcdhConvertKey(e),i=await this.EcdhConvertKey(t),s=await this.#t.subtle.deriveKey({name:"ECDH",public:a},i,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),n=await this.#t.subtle.exportKey("raw",s),o=this.arrayToBase64(new Uint8Array(n));return await this.AESEncrypt(o,r)};EcDecrypt=async(t,e,r,a)=>{let i=await this.EcdhConvertKey(e),s=await this.EcdhConvertKey(t),n=this.base64ToArray(r),o=this.base64ToArray(a),y=await this.#t.subtle.deriveKey({name:"ECDH",public:i},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);return await this.#t.subtle.decrypt({name:"AES-GCM",iv:n},y,o)};HKDFEncrypt=async(t,e,r)=>{await this.#r(0);let a=await this.EcdhConvertKey(e),i=await this.EcdhConvertKey(t),s=await this.#t.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:a},i,256),n=await this.#t.subtle.importKey("raw",s,{name:"HKDF"},!1,["deriveKey","deriveBits"]),o=this.#t.getRandomValues(new Uint8Array(16)),y=await this.#t.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:o,info:new Uint8Array([])},n,256),c=await this.#t.subtle.importKey("raw",y,"AES-GCM",!1,["encrypt","decrypt"]),h=this.#t.getRandomValues(new Uint8Array(16)),p=await this.#t.subtle.encrypt({name:"AES-GCM",iv:h},c,this.base64ToArray(r));return{ciphertext:this.arrayToBase64(new Uint8Array(p)),salt:this.arrayToBase64(o),iv:this.arrayToBase64(h)}};HKDFDecrypt=async(t,e,r,a,i)=>{await this.#r(0);let s,n=await this.EcdhConvertKey(e),o=await this.EcdhConvertKey(t),y=this.base64ToArray(r),c=this.base64ToArray(a),h=this.base64ToArray(i),p=await this.#t.subtle.deriveBits({name:"ECDH",namedCurve:"P-256",public:n},o,256),l=await this.#t.subtle.importKey("raw",p,{name:"HKDF"},!1,["deriveKey","deriveBits"]),w=await this.#t.subtle.deriveBits({name:"HKDF",hash:"SHA-256",salt:y,info:new Uint8Array([])},l,256),d=await this.#t.subtle.importKey("raw",w,"AES-GCM",!1,["encrypt","decrypt"]);try{s=await this.#t.subtle.decrypt({name:"AES-GCM",iv:c},d,h)}catch(t){console.log({name:t.name,stack:t.stack,message:t.message})}return s};EcMakeSigKeys=async(t=!0)=>{await this.#r(0);let e,r=await this.#t.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},t,["sign","verify"]);return t?(e=await Promise.all([this.#t.subtle.exportKey("spki",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t)))),this.#t.subtle.exportKey("pkcs8",r.privateKey).then((t=>this.arrayToBase64(new Uint8Array(t))))]),{publicKey:e[0],privateKey:e[1]}):(e=await Promise.all([this.#t.subtle.exportKey("spki",r.publicKey).then((t=>this.arrayToBase64(new Uint8Array(t))))]),{publicKey:e[0],privateKey:r.privateKey})};EcSignData=async(t,e)=>{await this.#r(0);let r=await this.EcdsaConvertKey(t),a=await this.#t.subtle.sign({name:"ECDSA",hash:{name:"SHA-256"}},r,this.base64ToArray(e));return await this.arrayToBase64(new Uint8Array(a))};EcVerifySig=async(t,e,r)=>{await this.#r(0);let a=await this.EcdsaConvertKey(t),i=this.base64ToArray(e);return await this.#t.subtle.verify({name:"ECDSA",hash:{name:"SHA-256"}},a,i,this.base64ToArray(r))};EcdhConvertKey=async t=>{let e,r;if(await this.#r(0),t instanceof this.#t.CryptoKey)return t;try{return e=await this.#t.subtle.importKey("spki",this.base64ToArray(t),{name:"ECDH",namedCurve:"P-256"},!0,[]),e}catch(t){}try{return e=await this.#t.subtle.importKey("raw",this.base64ToArray(t),{name:"ECDH",namedCurve:"P-256"},!0,[]),e}catch(t){}try{return e=await this.#t.subtle.importKey("pkcs8",this.base64ToArray(t),{name:"ECDH",namedCurve:"P-256"},!1,["deriveKey","deriveBits"]),e}catch(t){}try{return r=new Uint8Array([4].concat(Array.from(this.base64ToArray(t)))),e=await this.#t.subtle.importKey("raw",r,{name:"ECDH",namedCurve:"P-256"},!0,[]),e}catch(t){throw new Error("UNRECOGNIZED KEY FORMAT")}};EcdsaConvertKey=async t=>{let e,r;if(await this.#r(0),t instanceof this.#t.CryptoKey)return t;try{return e=await this.#t.subtle.importKey("spki",this.base64ToArray(t),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),e}catch(t){}try{return e=await this.#t.subtle.importKey("raw",this.base64ToArray(t),{name:"ECDSA",namedCurve:"P-256"},!0,["verify"]),e}catch(t){}try{return e=await this.#t.subtle.importKey("pkcs8",this.base64ToArray(t),{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),e}catch(t){}try{return r=new Uint8Array([4].concat(Array.from(this.base64ToArray(t)))),e=await this.#t.subtle.importKey("raw",r,{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),e}catch(t){throw new Error("UNRECOGNIZED KEY FORMAT")}}}class a{#a;#i;#s;#n=1;constructor(t,e){this.#i=document.createDocumentFragment(),this.#s=t,window.addEventListener("message",this.handlePost,!1);const r=document.createElement("iframe");r.srcdoc='\n    <!DOCTYPE html>\n    <html lang="en-US">\n      <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1" />\n        <link href="https://static.keyri.com/library-keyri-connect/iframe.css" rel="stylesheet">\n      </head>\n      <body>\n        <div class="pre-blurry" id="qr-target" style="height: 100%; width: 100%; z-index: -1" ></div>\n        <div\n          id="qr-lay-over"\n          onclick="main();"\n          style="height: 100%; width: 100%; position: absolute; top: 0; left: 0; z-index: 1"\n        ></div>\n      </body>\n    </html>\n    \n    <script>\n\n        const postMessage = window.parent.postMessage;\n        postMessage("HI MOM","*");\n\n        top = {location: {}}\n        self = {location: {host: top.location.host}};\n        parent = {location: {origin: location.origin}};\n        \n        window.parent.postMessage = (a,b) => {\n          console.log("POST-MESSAGE",{a,b});\n          return postMessage(a,"*")\n        }\n\n        postMessage("WAIT UNTIL THEY GET A LOAD OF ME...","*");\n\n    \n    <\/script>\n\n    <script src="https://static.keyri.com/library-keyri-connect/keyri-0.10.3.dev.min.js"><\/script>\n    ',r.style.padding="50px",r.style.width="350px",r.style.height="350px",r.style.borderWidth="0",r.style["vertical-align"]="middle",r.style.borderWidth="0",r.scrolling="no",e.innerHTML="",e.appendChild(r)}connect=async()=>(console.log("RUNNING CONNECT"),this.#a=new WebSocket(this.#s),new Promise(((t,e)=>{this.#a.onopen=e=>{t(e)},this.#a.onmessage=t=>{console.log("CONNECT METHOD",{message:t});let e=JSON.parse(t.data);e.o=JSON.parse(e.o);let r=e.i;this.#o(r.toString(),e)},this.#a.addEventListener("error",(t=>{this.#o("error",t),e(t)})),setTimeout((()=>{e(new Error("WS connect attempt timed out..."))}),5e3)})));send=async t=>(this.#n+=2,new Promise(((e,r)=>{let a=JSON.parse(t).i;this.on(a.toString(),(t=>{let a=t.detail;if("string"==typeof a.o.errormsg)return this.#o("error",a),r(a),!1;e(a)})),this.#a.send(t),setTimeout((()=>{r(new Error("WS send attempt timed out..."))}),5e3)})));authUser=async(t,e,a)=>{let i=window.crypto.getRandomValues(new Uint8Array(32)).join("").substring(0,13);const s={Nonce:i,UserId:a,APIKey:t,Signature:await r.hmac(e,`${i}${a}${t}`)};let n=JSON.stringify({m:0,i:this.#n,n:"AuthenticateUser",o:JSON.stringify(s)});return await this.send(n)};destroyAPIKey=async(t,e)=>{let r=JSON.stringify({m:0,i:this.#n,n:"RemoveUserAPIKey",o:JSON.stringify({UserId:e,APIKey:t})});return await this.send(r)};getAPIKeys=async(t,e)=>{let r=JSON.stringify({m:0,i:this.#n,n:"GetUserAPIKeys",o:JSON.stringify({UserId:e,APIKey:t})});return await this.send(r)};on=(t,e)=>{this.#i.addEventListener(t,e)};#o=(t,e)=>{this.#i.dispatchEvent(new CustomEvent(t,{detail:e}))};handlePost=async t=>{if(console.log("HANDLE-POST",{message:t}),"session_validate"===t?.data?.type){let e=JSON.parse(t?.data?.data),r=JSON.parse(e?.o).SessionToken;localStorage.token=r,setTimeout((()=>{window.location.reload()}),100)}}}window.WebApex=e.default})();
//# sourceMappingURL=WebApex.min.js.map