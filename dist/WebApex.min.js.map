{"version":3,"file":"WebApex.min.js","mappings":";mBACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,gCCQnE,MAAMI,EAEnB,GAEAC,cAEsB,oBAAVC,OACRC,MAAK,KAELA,MAAK,EAAUD,OAAOE,OACtBD,MAAK,EAAQE,UAAYH,OAAOG,UAEpC,CAIA,GAAeC,UACbH,MAAK,QAAiBZ,OAAOgB,gBAAeD,iBAAiB,IAAGL,YACpE,uFAD0BV,EAInB,EAKL,GAASe,MAAOE,UACR,IAAIC,SAAQ,CAACC,EAAEC,KAAOC,YAAW,IAAcF,GAAE,IAAOF,EAAQ,GAAG,EAiB3EK,cAAcC,GACZ,OAAOC,WAAWC,KAAKC,KAAKH,IAASI,GAAMA,EAAEC,WAAW,IAC1D,CAgBAC,cAAcC,GACZ,OAAOC,KAAKC,OAAOC,gBAAgBH,GACrC,CAmBAI,KAAOnB,MAAOoB,EAAQC,WACdxB,MAAK,EAAO,GAGlB,IAAIyB,EAAU,IAAIC,YAAY,SAC1BC,EAAgBF,EAAQG,OAAOL,GAC/BM,EAAcJ,EAAQG,OAAOJ,GAG7BtC,QAAYc,MAAK,EAAQ8B,OAAOC,UAClC,MACAJ,EACA,CAAEK,KAAM,OAAQC,KAAM,CAAED,KAAM,aAC9B,EACA,CAAC,OAAQ,WAIPE,QAAYlC,MAAK,EAAQ8B,OAAOK,KAAK,OAAQjD,EAAK2C,GAKlDO,EAAI,IAAIxB,WAAWsB,GAKvB,OAJUG,MAAM3C,UAAU4C,IACvB1C,KAAKwC,GAAIG,IAAO,KAAOA,EAAEC,SAAS,KAAKC,OAAO,KAC9CC,KAAK,GAEE,EAoBZC,KAAOxC,MAAOyC,EAAMpB,EAAMqB,KAExB,IAIIC,EAJAb,QAAajC,MAAK,EAAQ8B,OAAOiB,OAAOH,GAAM,IAAIlB,aAAcE,OAAOJ,IAEvEN,EAAM,IAAIN,WAAWqB,GAIzB,GAAGY,EAAI,CAELC,EAAS,IAAIlC,WAAWiC,EAAI,GAElBG,KAAKC,IAAIJ,EAAK3B,EAAIgC,QAA5B,IACIC,EAAMH,KAAKG,IAAIN,EAAK3B,EAAIgC,QAE5B,IAAI,IAAIE,EAAI,EAAGA,EAAID,EAAKC,IACtBN,EAAOM,EAAEP,GAAOC,EAAOM,EAAEP,GAAO3B,EAAIkC,EAAElC,EAAIgC,OAE9C,MACEJ,EAAS5B,EAGX,OAAOlB,KAAKiB,cAAc,IAAIL,WAAWkC,GAAQ,EAoBnDO,WAAalD,MAAOmD,GAAa,WACzBtD,MAAK,EAAO,GAGlB,IAAId,QAAYc,MAAK,EAAQ8B,OAAOyB,YAClC,CAAEvB,KAAM,UAAWkB,OAAQ,KAC3BI,EACA,CAAC,UAAW,YAKd,GAAGA,EAAW,CAGZ,IAAIE,QAAYxD,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOvE,GACrD,OAAOc,KAAKiB,cAAc,IAAIL,WAAW4C,GAC3C,CAGE,OAAOtE,CACT,EAkBFwE,aAAevD,MAAOwD,EAASL,GAAa,WACpCtD,MAAK,EAAO,GAGf2D,aAAmB3D,MAAK,EAAQE,UAC1ByD,QAIM3D,MAAK,EAAQ8B,OAAOC,UAC7B,MACA/B,KAAKU,cAAciD,GAASC,OAC5B,UACAN,EACA,CAAC,UAAW,aAoBpBnD,iBAAiB0D,EAAaC,EAAcC,GAAgB,SACpD/D,MAAK,EAAO,GAGlB,IAIIgE,EAJAL,QAAgB3D,KAAK0D,aAAaG,GAOpCG,EADCD,EACO/D,KAAKU,cAAcqD,GAEnB/D,MAAK,EAAQiE,gBAAgB,IAAIrD,WAAW,KAItD,IAAIsD,QAAkBlE,MAAK,EAAQ8B,OAAOqC,QACxC,CAAEnC,KAAM,UAAWoC,GAAIJ,GACvBL,EACA3D,KAAKU,cAAcoD,IAIrB,MAAO,CACLO,WAAYrE,KAAKiB,cAAc,IAAIL,WAAWsD,IAC9CE,GAAIpE,KAAKiB,cAAc+C,GAE3B,CAkBA7D,iBAAiB0D,EAAaE,EAAeO,EAAgBC,GAAa,SAClEvE,MAAK,EAAO,GAGlB,IAGIwE,EAHAb,QAAgB3D,KAAK0D,aAAaG,GAClCY,EAAYzE,KAAKU,cAAcqD,GAC/BW,EAAa1E,KAAKU,cAAc4D,GAYpC,OANAE,QAAkBxE,MAAK,EAAQ8B,OAAO6C,QACpC,CAAE3C,KAAM,UAAWoC,GAAIK,GACvBd,EACAe,GAGEH,GAGFC,EAAY,IAAI5D,WAAW4D,GAE3BA,GAAY,IAAII,aAAcC,OAAOL,GAE9BA,GANAA,CAQX,CAgBAM,gBAAkB3E,MAAOmD,GAAa,WAC9BtD,MAAK,EAAO,GAGlB,IAOI+E,EAPAC,QAAahF,MAAK,EAAQ8B,OAAOyB,YACnC,CAAEvB,KAAM,OAAQiD,WAAY,SAC5B3B,EACA,CAAC,YAAY,eA+Cf,OAxCEyB,EADCzB,QACkBhD,QAAQ4E,IAAI,CAC3BlF,MAAK,EAAQ8B,OAAO2B,UAAU,OAAQuB,EAAKG,WAAWC,MAAMlG,GACnDc,KAAKiB,cAAc,IAAIL,WAAW1B,MAE3Cc,MAAK,EAAQ8B,OAAO2B,UAAU,QAASuB,EAAKK,YAAYD,MAAMlG,GACrDc,KAAKiB,cAAc,IAAIL,WAAW1B,MAE3Cc,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOuB,EAAKG,WAAWC,MAAMlG,GAClD,IAETc,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOuB,EAAKK,YAAYD,MAAMlG,GACnD,IAETc,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOuB,EAAKG,WAAWC,MAAMlG,GAClDc,KAAKiB,cAAe,IAAIL,WAAW1B,MAE5Cc,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOuB,EAAKG,WAAWC,MAAMlG,GAClDc,KAAKiB,cAAe,IAAIL,WAAW1B,GAAKuD,MAAM,EAAE,gBAK1CnC,QAAQ4E,IAAI,CAE3BlF,MAAK,EAAQ8B,OAAO2B,UAAU,OAAQuB,EAAKG,WAAWC,MAAMlG,GACnDc,KAAKiB,cAAc,IAAIL,WAAW1B,MAG7C,IAAKoB,SAAQ,CAACC,EAAEC,IAAcD,EAAEyE,EAAKK,cAEnCrF,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOuB,EAAKG,WAAWC,MAAMlG,GAClDc,KAAKiB,cAAe,IAAIL,WAAW1B,MAG5Cc,MAAK,EAAQ8B,OAAO2B,UAAU,MAAOuB,EAAKG,WAAWC,MAAMlG,GAClDc,KAAKiB,cAAe,IAAIL,WAAW1B,GAAKuD,MAAM,EAAE,UAK5Da,EACM,CACL6B,UAAWJ,EAAW,GACtBM,WAAYN,EAAW,GACvBO,aAAcP,EAAW,GACzBQ,cAAeR,EAAW,GAC1BS,aAAcT,EAAW,GACzBU,iBAAkBV,EAAW,IAGtB,CACLI,UAAWJ,EAAW,GACtBM,WAAYN,EAAW,GACvBS,aAAcT,EAAW,GACzBU,iBAAkBV,EAAW,GAEnC,EA4BFW,UAAYvF,MAAOwF,EAAYC,EAAWC,WAClC7F,MAAK,EAAO,GAIlB,IAAImF,QAAkBnF,KAAK8F,eAAeF,GACtCP,QAAmBrF,KAAK8F,eAAeH,GAGvChC,QAAgB3D,MAAK,EAAQ8B,OAAOiE,UACtC,CAAE/D,KAAM,OAAQgE,OAAQb,GACxBE,EACA,CAAErD,KAAM,UAAWkB,OAAQ,MAC3B,EACA,CAAC,UAAW,YAIV+C,QAAoBjG,MAAK,EAAQ8B,OAAO2B,UAAU,MAAME,GAGxDuC,EAAclG,KAAKiB,cAAc,IAAIL,WAAWqF,IAGpD,aAAajG,KAAKmG,WAAWD,EAAaL,EAAQ,EA4BpDO,UAAYjG,MAAOwF,EAAYC,EAAWS,EAAUR,KAIlD,IAAIV,QAAkBnF,KAAK8F,eAAeF,GACtCP,QAAmBrF,KAAK8F,eAAeH,GACvC3B,EAAQhE,KAAKU,cAAc2F,GAC3B7E,EAAOxB,KAAKU,cAAcmF,GAG1BlC,QAAgB3D,MAAK,EAAQ8B,OAAOiE,UACtC,CAAE/D,KAAM,OAAQgE,OAAQb,GACxBE,EACA,CAAErD,KAAM,UAAWkB,OAAQ,MAC3B,EACA,CAAC,UAAW,YAId,aAAalD,MAAK,EAAQ8B,OAAO6C,QAC/B,CAAE3C,KAAM,UAAWoC,GAAIJ,GACvBL,EACAnC,EACD,EA6CH8E,YAAcnG,MAAOwF,EAAYC,EAAWC,WACpC7F,MAAK,EAAO,GAIlB,IAAImF,QAAkBnF,KAAK8F,eAAeF,GACtCP,QAAmBrF,KAAK8F,eAAeH,GAIvCY,QAAqBvG,MAAK,EAAQ8B,OAAO0E,WAAW,CACtD,KAAQ,OACR,WAAc,QACd,OAAUrB,GACVE,EAAW,KAIToB,QAAwBzG,MAAK,EAAQ8B,OAAOC,UAC9C,MAAOwE,EACP,CAAE,KAAQ,SACV,EACA,CAAC,YAAY,eAKXG,EAAO1G,MAAK,EAAQiE,gBAAgB,IAAIrD,WAAW,KAInD+F,QAAmB3G,MAAK,EAAQ8B,OAAO0E,WAAW,CACpD,KAAQ,OACR,KAAQ,UACR,KAAQE,EACR,KAAQ,IAAI9F,WAAW,KACvB6F,EAAgB,KAQd9C,QAAgB3D,MAAK,EAAQ8B,OAAOC,UACtC,MACA4E,EACA,WACA,EACA,CAAC,UAAU,YAMTvC,EAAKpE,MAAK,EAAQiE,gBAAgB,IAAIrD,WAAW,KAKjDsD,QAAkBlE,MAAK,EAAQ8B,OAAOqC,QACxC,CAAEnC,KAAM,UAAWoC,GAAIA,GACvBT,EACA3D,KAAKU,cAAcmF,IAIrB,MAAO,CACL,WAAc7F,KAAKiB,cAAc,IAAIL,WAAWsD,IAChD,KAAQlE,KAAKiB,cAAcyF,GAC3B,GAAM1G,KAAKiB,cAAcmD,GAC1B,EA6BHwC,YAAczG,MAAOwF,EAAYC,EAAWiB,EAASC,EAAOjB,WACpD7F,MAAK,EAAO,GAIlB,IAiDI+G,EAjDA5B,QAAkBnF,KAAK8F,eAAeF,GAEtCP,QAAmBrF,KAAK8F,eAAeH,GAEvCe,EAAO1G,KAAKU,cAAcmG,GAC1BzC,EAAKpE,KAAKU,cAAcoG,GACxBtF,EAAOxB,KAAKU,cAAcmF,GAK1BU,QAAqBvG,MAAK,EAAQ8B,OAAO0E,WAAW,CACtD,KAAQ,OACR,WAAc,QACd,OAAUrB,GACVE,EAAW,KAIToB,QAAwBzG,MAAK,EAAQ8B,OAAOC,UAC9C,MAAOwE,EACP,CAAE,KAAQ,SACV,EACA,CAAC,YAAY,eAKXI,QAAmB3G,MAAK,EAAQ8B,OAAO0E,WAAW,CACpD,KAAQ,OACR,KAAQ,UACR,KAAQE,EACR,KAAQ,IAAI9F,WAAW,KACvB6F,EAAgB,KAMd9C,QAAgB3D,MAAK,EAAQ8B,OAAOC,UACtC,MACA4E,EACA,WACA,EACA,CAAC,UAAU,YAMb,IACII,QAAiB/G,MAAK,EAAQ8B,OAAO6C,QACrC,CAAE3C,KAAM,UAAWoC,GAAIA,GACvBT,EACAnC,EAIJ,CAFE,MAAMwF,GACNC,QAAQC,IAAI,CAAClF,KAAMgF,EAAEhF,KAAMmF,MAAOH,EAAEG,MAAOC,QAASJ,EAAEI,SACxD,CAEA,OAAOL,CAAQ,EAiCjBM,cAAgBlH,MAAOmD,GAAa,WAC5BtD,MAAK,EAAO,GAGlB,IAMIsH,EANAtC,QAAahF,MAAK,EAAQ8B,OAAOyB,YACnC,CAAEvB,KAAM,QAASiD,WAAY,SAC7B3B,EACA,CAAC,OAAO,WAMV,OAAGA,GACDgE,QAAgBhH,QAAQ4E,IAAI,CAC1BlF,MAAK,EAAQ8B,OAAO2B,UAAU,OAAQuB,EAAKG,WAAWC,MAAMlG,GACnDc,KAAKiB,cAAc,IAAIL,WAAW1B,MAE3Cc,MAAK,EAAQ8B,OAAO2B,UAAU,QAASuB,EAAKK,YAAYD,MAAMlG,GACrDc,KAAKiB,cAAc,IAAIL,WAAW1B,QAItC,CAAEiG,UAAWmC,EAAQ,GAAIjC,WAAYiC,EAAQ,MAKpDA,QAAgBhH,QAAQ4E,IAAI,CAC1BlF,MAAK,EAAQ8B,OAAO2B,UAAU,OAAQuB,EAAKG,WAAWC,MAAMlG,GACnDc,KAAKiB,cAAc,IAAIL,WAAW1B,QAGtC,CAAEiG,UAAWmC,EAAQ,GAAIjC,WAAYL,EAAKK,YACnD,EAqBFkC,WAAapH,MAAOqH,EAAe3B,WAC3B7F,MAAK,EAAO,GAGlB,IAAIqF,QAAmBrF,KAAKyH,gBAAgBD,GAGxCE,QAAkB1H,MAAK,EAAQ8B,OAAOK,KAAK,CAAC,KAAQ,QAAS,KAAQ,CAAC,KAAQ,YAAakD,EAAYrF,KAAKU,cAAcmF,IAG9H,aAAc7F,KAAKiB,cAAc,IAAIL,WAAW8G,GAAW,EAqB7DC,YAAcxH,MAAOyH,EAAcC,EAAchC,WACzC7F,MAAK,EAAO,GAGlB,IAAImF,QAAkBnF,KAAKyH,gBAAgBG,GAIvCF,EAAY1H,KAAKU,cAAcmH,GAGnC,aAAa7H,MAAK,EAAQ8B,OAAOgG,OAAO,CAAC,KAAQ,QAAS,KAAQ,CAAC,KAAQ,YAAa3C,EAAWuC,EAAW1H,KAAKU,cAAcmF,GAAS,EA2B5IC,eAAiB3F,MAAO4H,IAGtB,IAAI7I,EACA8I,EAKJ,SARMhI,MAAK,EAAO,GAQf+H,aAAuB/H,MAAK,EAAQE,UACrC,OAAO6H,EAST,IAQE,OAPA7I,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,OACA/B,KAAKU,cAAcqH,GACnB,CAAE/F,KAAM,OAAQiD,WAAY,UAC5B,EACA,IAEK/F,CAEE,CAAT,MAAM8H,GAAG,CAQX,IAQE,OAPA9H,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,MACA/B,KAAKU,cAAcqH,GACnB,CAAE/F,KAAM,OAAQiD,WAAY,UAC5B,EACA,IAEK/F,CAEE,CAAT,MAAM8H,GAAG,CAQX,IAQE,OAPA9H,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,QACA/B,KAAKU,cAAcqH,GACnB,CAAE/F,KAAM,OAAQiD,WAAY,UAC5B,EACA,CAAC,YAAY,eAER/F,CAEE,CAAT,MAAM8H,GAAG,CAQX,IAUE,OARAgB,EAAU,IAAIpH,WAAW,CAAC,GAAGqH,OAAO5F,MAAMxB,KAAKb,KAAKU,cAAcqH,MAClE7I,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,MACAiG,EACA,CAAEhG,KAAM,OAAQiD,WAAY,UAC5B,EACA,IAEK/F,CAIT,CAFE,MAAM8H,GACN,MAAM,IAAIkB,MAAM,0BAClB,GAwBFT,gBAAkBtH,MAAO4H,IAGvB,IAAI7I,EACA8I,EAOJ,SAVMhI,MAAK,EAAO,GAUf+H,aAAuB/H,MAAK,EAAQE,UACrC,OAAO6H,EAWT,IAUE,OARA7I,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,OACA/B,KAAKU,cAAcqH,GACnB,CAAE/F,KAAM,QAASiD,WAAY,UAC7B,EACA,CAAC,WAGI/F,CAEE,CAAT,MAAM8H,GAAG,CASX,IAUE,OARA9H,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,MACA/B,KAAKU,cAAcqH,GACnB,CAAE/F,KAAM,QAASiD,WAAY,UAC7B,EACA,CAAC,WAGI/F,CAEE,CAAT,MAAM8H,GAAG,CASX,IAUE,OARA9H,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,QACA/B,KAAKU,cAAcqH,GACnB,CAAE/F,KAAM,QAASiD,WAAY,UAC7B,EACA,CAAC,SAGI/F,CAEE,CAAT,MAAM8H,GAAG,CASX,IAWE,OATAgB,EAAU,IAAIpH,WAAW,CAAC,GAAGqH,OAAO5F,MAAMxB,KAAKb,KAAKU,cAAcqH,MAClE7I,QAAYc,MAAK,EAAQ8B,OAAOC,UAC9B,MACAiG,EACA,CAAEhG,KAAM,QAASiD,WAAY,UAC7B,EACA,CAAC,SAGI/F,CAIT,CAFE,MAAM8H,GACN,MAAM,IAAIkB,MAAM,0BAClB,GChkCW,MAAMC,EAInB,GACA,GACA,GACA,GAAY,EAmBZrI,YAAYsI,EAAWC,GAIrBrI,MAAK,EAASsI,SAASC,yBACvBvI,MAAK,EAAaoI,EA6ClBrI,OAAOyI,iBAAiB,UAAWxI,KAAKyI,YAAY,GAEpD,MAAMC,EAAUJ,SAASK,cAAc,UACvCD,EAAQE,OA3CU,2sCA4ClBF,EAAQG,MAAMC,QAAU,OACxBJ,EAAQG,MAAME,MAAQ,QACtBL,EAAQG,MAAMG,OAAS,QACvBN,EAAQG,MAAMI,YAAc,IAC5BP,EAAQG,MAAM,kBAAoB,SAClCH,EAAQG,MAAMI,YAAc,IAC5BP,EAAQQ,UAAY,KAGpBb,EAAcc,UAAY,GAC1Bd,EAAce,YAAYV,EAC5B,CAiBAW,QAAUlJ,UAER8G,QAAQC,IAAI,mBAMZlH,MAAK,EAAU,IAAIsJ,UAAUtJ,MAAK,GAQ3B,IAAIM,SAAQ,CAACiJ,EAASC,KAE3BxJ,MAAK,EAAQyJ,OAAUC,IACrBH,EAAQG,EAAM,EAKhB1J,MAAK,EAAQ2J,UAAavC,IAExBH,QAAQC,IAAI,iBAAiB,CAACE,YAE9B,IAAIwC,EAAOC,KAAKC,MAAM1C,EAAQ5F,MAE9BoI,EAAKzK,EAAI0K,KAAKC,MAAMF,EAAKzK,GAEzB,IAAI4K,EAAKH,EAAKxG,EAEdpD,MAAK,EAAW+J,EAAGvH,WAAYoH,EAAK,EAKtC5J,MAAK,EAAQwI,iBACX,SACCwB,IACChK,MAAK,EAAW,QAASgK,GACzBR,EAAOQ,EAAI,IAKfvJ,YAAW,KACT+I,EAAO,IAAItB,MAAM,mCAAmC,GACnD,IAAM,KAoBb+B,KAAO9J,MAAOqB,IAEZxB,MAAK,GAAa,EAGX,IAAIM,SAAQ,CAACiJ,EAASC,KAG3B,IAAIU,EAAWL,KAAKC,MAAMtI,GAAM4B,EAGhCpD,KAAKmK,GAAGD,EAAS1H,YAAY4H,IAGzB,IAAIC,EAAQD,EAAKE,OAGjB,GAA+B,iBAApBD,EAAMlL,EAAEoL,SAGjB,OAFAvK,MAAK,EAAW,QAASqK,GACzBb,EAAOa,IACA,EAEPd,EAAQc,EACV,IAQJrK,MAAK,EAAQiK,KAAKzI,GAMlBf,YAAW,KACT+I,EAAO,IAAItB,MAAM,gCAAgC,GAChD,IAAM,KAqBbsC,SAAWrK,MAAOsK,EAAQC,EAAWC,KAEnC,IAAIC,EAAQ7K,OAAOE,OAChBgE,gBAAgB,IAAIrD,WAAW,KAC/B8B,KAAK,IACLmI,UAAU,EAAG,IAOhB,MAAMC,EAAQ,CAAEF,QAAOD,SAAQF,SAAQM,gBANjBlL,EAASmL,KAC7BN,EACA,GAAGE,IAAQD,IAASF,MAOtB,IAAIQ,EAAUpB,KAAKqB,UAAU,CAC3BC,EAAG,EACH/H,EAAGpD,MAAK,EACRoL,EAAG,mBACHjM,EAAG0K,KAAKqB,UAAUJ,KAKpB,aAFiB9K,KAAKiK,KAAKgB,EAEhB,EAmBbI,cAAgBlL,MAAOsK,EAAQE,KAC7B,IAAIM,EAAUpB,KAAKqB,UAAU,CAC3BC,EAAG,EACH/H,EAAGpD,MAAK,EACRoL,EAAG,mBACHjM,EAAG0K,KAAKqB,UAAU,CAAEP,OAAQA,EAAQF,OAAQA,MAK9C,aAFiBzK,KAAKiK,KAAKgB,EAEhB,EAkBbK,WAAanL,MAAOsK,EAAQE,KAC1B,IAAIM,EAAUpB,KAAKqB,UAAU,CAC3BC,EAAG,EACH/H,EAAGpD,MAAK,EACRoL,EAAG,iBACHjM,EAAG0K,KAAKqB,UAAU,CAAEP,OAAQA,EAAQF,OAAQA,MAK9C,aAFiBzK,KAAKiK,KAAKgB,EAEhB,EAwBbd,GAAK,CAACoB,EAAWC,KACfxL,MAAK,EAAOwI,iBAAiB+C,EAAWC,EAAa,EAyBvD,GAAa,CAACD,EAAWE,KACvBzL,MAAK,EAAO0L,cACV,IAAIC,YAAYJ,EAAW,CAAEjB,OAAQmB,IACtC,EAiBHhD,WAAatI,MAAOiH,IAKlB,GAHAH,QAAQC,IAAI,cAAe,CAACE,YAGA,qBAAxBA,GAAS5F,MAAMoK,KAA6B,CAE9C,IAAIC,EAAchC,KAAKC,MAAM1C,GAAS5F,MAAMA,MAExCsK,EADsBjC,KAAKC,MAAM+B,GAAa1M,GACE4M,aAEpDC,aAAaC,MAAQH,EAErBrL,YAAW,KACTV,OAAOmM,SAASC,QAAQ,GACvB,IACL","sources":["webpack://WebApex/webpack/bootstrap","webpack://WebApex/webpack/runtime/define property getters","webpack://WebApex/webpack/runtime/hasOwnProperty shorthand","webpack://WebApex/./node_modules/ezcrypto/index.js","webpack://WebApex/./js/WebApex.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// ////////////////////////////////////////////////////////////////////////////\n// ////////////////////////////////////////////////////////////////////////////\n// ////////////////////////////////////////////////////////////////////////////\n//\n// Class with methods to make working with subtle crypto\n// easier and more obvious\n//\n\nexport default class EZCrypto {\n  \n  #crypto;\n  \n  constructor() {\n   \n    if(typeof window == \"undefined\"){    \n      this.#nodeEnvLoad();\n    } else {\n      this.#crypto = window.crypto;\n      this.#crypto.CryptoKey = window.CryptoKey;\n    }\n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  #nodeEnvLoad = async () => {\n    this.#crypto =  await Object.getPrototypeOf(async function(){}).constructor(\n`\n      return await import( \"crypto\" ).then((m) => {return m.default.webcrypto});\n`\n    )();  \n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  #sleep = async (duration) => {\n    await new Promise((s,j) => {setTimeout(() => {return s(true)},duration)});\n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     base64ToArray\n  // What is this: Take a base64 string. Convert it to a Uint8Array...\n  //\n  // Arguments:    strng: - base64 encoded string\n  //\n  // Returns:      Uint8Array\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  base64ToArray(strng) {\n    return Uint8Array.from(atob(strng), (c) => c.charCodeAt(0));\n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     arrayToBase64\n  // What is this: take a Uint8Array, make it a valid base64 string\n  //\n  // Arguments:    ary: - Uint8Array\n  //\n  // Returns:      Base64 String\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  arrayToBase64(ary) {\n    return btoa(String.fromCharCode(...ary));\n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     hmac (static) (async)\n  // What is this: Create a cryptographic signature for a piece of data given a *SHARED* secret.\n  //               Similar to ECDSA - Except both parties have to have the secret-key in advance\n  //               to make it work.\n  //\n  // Arguments:    secret - this is the shared secret\n  //               data   - this is the string you're encrypting\n  //\n  // Returns:      hex encoded 32 character string or something...(todo: check length - better def)\n  // Notes:        https://stackoverflow.com/questions/47329132/how-to-get-hmac-with-crypto-web-api#47332317\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  HMAC = async (secret, data) => {\n    await this.#sleep(0);\n\n    // To do work, we need to convert text to Uint8Arrays\n    let encoder = new TextEncoder(\"utf-8\");\n    let encodedSecret = encoder.encode(secret);\n    let encodedData = encoder.encode(data);\n\n    // Create our HMAC Key\n    let key = await this.#crypto.subtle.importKey(\n      \"raw\",\n      encodedSecret,\n      { name: \"HMAC\", hash: { name: \"SHA-256\" } },\n      false,\n      [\"sign\", \"verify\"]\n    );\n\n    // HMAC Sign our data with our HMAC Key\n    let sig = await this.#crypto.subtle.sign(\"HMAC\", key, encodedData);\n\n    // Turn the signature into an array; then into hex-text\n    // (todo: Maybe this is its own method...?)\n    //\n    let b = new Uint8Array(sig);\n    let str = Array.prototype.map\n      .call(b, (x) => (\"00\" + x.toString(16)).slice(-2))\n      .join(\"\");\n\n    return str;\n  }\n\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     HASH (static) (async)\n  // What is this: The digest() method of the SubtleCrypto interface generates a digest of the given data. \n  //               A digest is a short fixed-length value derived from some variable-length input.\n  //               Cryptographic digests should exhibit collision-resistance, meaning that it's hard to come up \n  //               with two different inputs that have the same digest value.\n  //\n  // Arguments:    algo - this is the string you're hashing for\n  //               data   - This is the algorithm you're using to hash the data with (SHA-1, SHA-256, SHA-384, SHA-512)\n  //\n  // Returns:      the hash of the data you provided as a base64 string\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  HASH = async (algo, data, len) => {\n\n    let hash = await this.#crypto.subtle.digest(algo, new TextEncoder().encode(data));\n    \n    let ary = new Uint8Array(hash);\n\n    let outAry;\n\n    if(len){\n      // initialize outAry to the desired size\n      outAry = new Uint8Array(len,0);\n\n      let min = Math.min(len, ary.length);\n      let max = Math.max(len, ary.length);\n\n      for(var i = 0; i < max; i++){\n        outAry[i%len] = outAry[i%len] ^ ary[i%ary.length];\n      }\n    } else {\n      outAry = ary;\n    }\n\n    return this.arrayToBase64(new Uint8Array(outAry));\n\n  }\n\n\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     AESMakeKey (async)\n  // What is this: Generate an AES Key and return its hex\n  //\n  // Arguments:    *NONE*\n  //\n  // Returns:      base64 string\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  AESMakeKey = async (exportable = true) => {\n    await this.#sleep(0);\n\n    // 1.) Generate the Key\n    let key = await this.#crypto.subtle.generateKey(\n      { name: \"AES-GCM\", length: 256 },\n      exportable,\n      [\"encrypt\", \"decrypt\"]\n    );\n\n\n    // 2.) \n    if(exportable){\n      //Return it as b64 if its exportable\n      \n      let out = await this.#crypto.subtle.exportKey(\"raw\", key);\n      return this.arrayToBase64(new Uint8Array(out));\n    } else {\n      // else return the CryptoKey Object\n      \n      return key;\n    }\n  };\n  \n  \n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     AESImportKey (async)\n  // What is this: Generate an AES Key and return its hex\n  //\n  // Arguments:    base64 string\n  //\n  // Returns:      Live AES Key\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  AESImportKey = async (aes_key, exportable = true) => {\n    await this.#sleep(0);\n\n\n    if(aes_key instanceof this.#crypto.CryptoKey){\n      return aes_key;\n    } else {\n\n      // 1.) Generate the Key\n      return await this.#crypto.subtle.importKey(\n          \"raw\",\n          this.base64ToArray(aes_key).buffer,\n          \"AES-GCM\",\n          exportable,\n          [\"encrypt\", \"decrypt\"]\n        );\n    }\n  };\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     AESEncrypt (async)\n  // What is this: Given\n  //\n  // Arguments:    key:  base64 AES-key\n  //               data: uInt8Array\n  //\n  // Returns:      base64 string\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  async AESEncrypt(base_64_key, base_64_data, base_64_nonce = false) {\n    await this.#sleep(0);\n    \n    // 0.) Pass Key to \n    let aes_key = await this.AESImportKey(base_64_key);\n\n\n    // 3.) Create a nonce why not?\n    let nonce;\n    \n    if(base_64_nonce){\n      nonce = this.base64ToArray(base_64_nonce);\n    } else {\n      nonce = this.#crypto.getRandomValues(new Uint8Array(16));\n    }\n\n    // 4.) encrypt our data\n    let encrypted = await this.#crypto.subtle.encrypt(\n      { name: \"AES-GCM\", iv: nonce },\n      aes_key,\n      this.base64ToArray(base_64_data)\n    );\n\n    // 5.) Base64 and return our data...\n    return {\n      ciphertext: this.arrayToBase64(new Uint8Array(encrypted)),\n      iv: this.arrayToBase64(nonce),\n    };\n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     AESDecrypt (async)\n  // What is this: Given\n  //\n  // Arguments:    key:  base64 AES-key\n  //               nonce: base64 of the nonce used at encryption (ok if it is public)\n  //               ciphertext: base64 of what's been encoded\n  //\n  // Returns:      base64 string\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  async AESDecrypt(base_64_key, base_64_nonce, base_64_cipher, returnText = false) {\n    await this.#sleep(0);\n\n    // 1.) Convert out from base64 to array\n    let aes_key = await this.AESImportKey(base_64_key);\n    let nonce_ary = this.base64ToArray(base_64_nonce);\n    let cipher_ary = this.base64ToArray(base_64_cipher);\n    let decrypted;\n\n\n\n    // 3.) Decrypt\n    decrypted = await this.#crypto.subtle.decrypt(\n      { name: \"AES-GCM\", iv: nonce_ary },\n      aes_key,\n      cipher_ary\n    );\n\n    if(!returnText){\n      return decrypted;\n    } else {\n      decrypted = new Uint8Array(decrypted);\n\n      decrypted = new TextDecoder().decode(decrypted);\n\n      return decrypted;\n    }\n  }\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcMakeCryptKeys (async)\n  // What is this: Given\n  //\n  // Arguments:    none\n  //\n  // Returns:      object containing public and private key pair\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  EcMakeCryptKeys = async (exportable = true) => {\n    await this.#sleep(0);\n\n    // Step 1) Create ECDH KeyS\n    let keys = await this.#crypto.subtle.generateKey(\n      { name: \"ECDH\", namedCurve: \"P-256\" },\n      exportable,\n      [\"deriveKey\",\"deriveBits\"]\n    );\n\n    // Step 2) Export keys to SPKI|PKCS8|JWK|RAW format\n    let exportKeys;\n\n    if(exportable){\n      exportKeys = await Promise.all([\n          this.#crypto.subtle.exportKey(\"spki\", keys.publicKey).then((key) => {\n            return this.arrayToBase64(new Uint8Array(key));\n          }),\n          this.#crypto.subtle.exportKey(\"pkcs8\", keys.privateKey).then((key) => {\n            return this.arrayToBase64(new Uint8Array(key));\n          }),\n          this.#crypto.subtle.exportKey(\"jwk\", keys.publicKey).then((key) => {\n            return (key);\n          }),\n          this.#crypto.subtle.exportKey(\"jwk\", keys.privateKey).then((key) => {\n            return (key);\n          }),\n          this.#crypto.subtle.exportKey(\"raw\", keys.publicKey).then((key) => {\n            return this.arrayToBase64( new Uint8Array(key));\n          }),\n          this.#crypto.subtle.exportKey(\"raw\", keys.publicKey).then((key) => {\n            return this.arrayToBase64( new Uint8Array(key).slice(1,1000));\n          })\n      ]);\n      \n    } else {\n      exportKeys = await Promise.all([\n        //\n          this.#crypto.subtle.exportKey(\"spki\", keys.publicKey).then((key) => {\n            return this.arrayToBase64(new Uint8Array(key));\n          }),\n        //\n        (new Promise((s,j) => {return s(keys.privateKey)})),\n        //\n          this.#crypto.subtle.exportKey(\"raw\", keys.publicKey).then((key) => {\n            return this.arrayToBase64( new Uint8Array(key));\n          }),\n        //\n          this.#crypto.subtle.exportKey(\"raw\", keys.publicKey).then((key) => {\n            return this.arrayToBase64( new Uint8Array(key).slice(1,1000));\n          })\n      ]);\n    }\n\n    if(exportable){\n      return { \n        publicKey: exportKeys[0], \n        privateKey: exportKeys[1], \n        jwkPublicKey: exportKeys[2], \n        jwkPrivateKey: exportKeys[3], \n        rawPublicKey: exportKeys[4],\n        rawPublicKeyLite: exportKeys[5]\n      };\n    } else {\n        return { \n          publicKey: exportKeys[0], \n          privateKey: exportKeys[1], \n          rawPublicKey: exportKeys[2], \n          rawPublicKeyLite: exportKeys[3]\n        };\n    }\n\n    // Step 3) Convert the keys to base64 and return...\n  };\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcEncrypt (async)\n  // What is this: Encrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.\n  //               ---\n  //               Basically it does the dirty work of:\n  //               - convert base64 keys to live keys\n  //               - creating AES key from live keys\n  //               - encrypting data with AES Key\n  //               - return base64 ciphertext and nonce\n  //\n  //\n  // Arguments:    base64privateKey: string;\n  //               base64publicKey: string;\n  //               base64data: string;\n  //\n  // Returns:      object containing public and private key pair\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  EcEncrypt = async (b64Private, b64Public, b64data) => {\n    await this.#sleep(0);\n\n    // 1.) convert the given keys to real keys in the most\n    //     generic way possible...\n    let publicKey = await this.EcdhConvertKey(b64Public);\n    let privateKey = await this.EcdhConvertKey(b64Private);\n    \n    // 2.) generate shared key\n    let aes_key = await this.#crypto.subtle.deriveKey(\n      { name: \"ECDH\", public: publicKey },\n      privateKey,\n      { name: \"AES-GCM\", length: 256 },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    )\n    \n    // 3.) convert it out to data-array\n    let aes_key_raw = await this.#crypto.subtle.exportKey(\"raw\",aes_key);\n    \n    // 4.) convert that to base64\n    let b64_aes_key = this.arrayToBase64(new Uint8Array(aes_key_raw));\n    \n    // 5.) Work smarter, not harder, dummy...\n    return await this.AESEncrypt(b64_aes_key, b64data);\n  \n  };\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcDecrypt (async)\n  // What is this: Decrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.\n  //               ---\n  //               Basically it does the dirty work of:\n  //               - convert base64 keys to live keys\n  //               - creating AES key from live keys\n  //               - encrypting data with AES Key\n  //               - return base64 ciphertext and nonce\n  //\n  //\n  // Arguments:    base64privateKey: string;\n  //               base64publicKey: string;\n  //               base64nonce: string;\n  //               base64data: string;\n  //\n  // Returns:      object containing public and private key pair\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  EcDecrypt = async (b64Private, b64Public, b64Nonce, b64data) => {\n\n    // 1.) convert the given keys to real keys in the most\n    //     generic way possible...\n    let publicKey = await this.EcdhConvertKey(b64Public);\n    let privateKey = await this.EcdhConvertKey(b64Private);\n    let nonce = this.base64ToArray(b64Nonce);\n    let data = this.base64ToArray(b64data);\n\n    // 2.) generate shared key\n    let aes_key = await this.#crypto.subtle.deriveKey(\n      { name: \"ECDH\", public: publicKey },\n      privateKey,\n      { name: \"AES-GCM\", length: 256 },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n\n    // 4.) encrypt our data\n    return await this.#crypto.subtle.decrypt(\n      { name: \"AES-GCM\", iv: nonce },\n      aes_key,\n      data\n    );\n  };\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     HKDFEncrypt (async)\n  // What is this: Encrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.\n  //               ---\n  //               Basically it does the dirty work of:\n  //               - convert base64 keys to live keys\n  //               - creating AES key from live keys\n  //               - encrypting data with AES Key\n  //               - return base64 ciphertext and nonce\n  //\n  //\n  // Arguments:    base64privateKey: string;\n  //               base64publicKey: string;\n  //               base64data: string;\n  //\n  // Returns:      object containing public and private key pair\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  HKDFEncrypt = async (b64Private, b64Public, b64data) => {\n    await this.#sleep(0);\n\n    // 1.) convert the given keys to real keys in the most\n    //     generic way possible...\n    let publicKey = await this.EcdhConvertKey(b64Public);\n    let privateKey = await this.EcdhConvertKey(b64Private);\n    \n    // 2.) generate shared secret for HKDF\n    //\n    let sharedSecret = await this.#crypto.subtle.deriveBits({ \n      \"name\": \"ECDH\", \n      \"namedCurve\": \"P-256\", \n      \"public\": publicKey \n    },privateKey,256);\n    \n    // 3.) convert shared-secret into a key\n    //\n    let sharedSecretKey = await this.#crypto.subtle.importKey(\n      \"raw\", sharedSecret, \n      { \"name\": 'HKDF' }, \n      false, \n      ['deriveKey','deriveBits']\n    );\n    \n    // 4.) create SALT\n    //\n    let salt = this.#crypto.getRandomValues(new Uint8Array(16));\n    \n    // 5.) convert the live-shared-secret-key into an aes key\n    //\n    let derivedKey = await this.#crypto.subtle.deriveBits({\n      \"name\": 'HKDF', \n      \"hash\": 'SHA-256', \n      \"salt\": salt,\n      \"info\": new Uint8Array([])},\n      sharedSecretKey,256\n    );\n    \n    //\n    // 6.) \n    // THIS SHOULD NOT BE THIS HARD!\n    //\n    //     Convert the Key-Array to a live Key\n    let aes_key = await this.#crypto.subtle.importKey(\n      \"raw\",\n      derivedKey,\n      \"AES-GCM\",\n      false,\n      [\"encrypt\",\"decrypt\"]\n    );\n    \n    // 7.) Init Vector\n    //\n    //\n    let iv = this.#crypto.getRandomValues(new Uint8Array(16));\n    \n    // 7.) Encrypt\n    //\n    //\n    let encrypted = await this.#crypto.subtle.encrypt(\n      { name: \"AES-GCM\", iv: iv },\n      aes_key,\n      this.base64ToArray(b64data)\n    );\n    \n    // 8.) Base64 and return our data...\n    return {\n      \"ciphertext\": this.arrayToBase64(new Uint8Array(encrypted)),\n      \"salt\": this.arrayToBase64(salt),\n      \"iv\": this.arrayToBase64(iv)\n    };\n\n  \n  };\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     HKDFDecrypt (async)\n  // What is this: Decrypt Uint8Data with 2 SPKI-Encoded ECDH Keys.\n  //               ---\n  //               Basically it does the dirty work of:\n  //               - convert base64 keys to live keys\n  //               - creating AES key from live keys\n  //               - encrypting data with AES Key\n  //               - return base64 ciphertext and nonce\n  //\n  //\n  // Arguments:    base64privateKey: string;\n  //               base64publicKey: string;\n  //               base64nonce: string;\n  //               base64data: string;\n  //\n  // Returns:      object containing public and private key pair\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  HKDFDecrypt = async (b64Private, b64Public, b64Salt, b64iv, b64data) => {\n    await this.#sleep(0);\n\n    // 1.) convert the given keys to real keys in the most\n    //     generic way possible...\n    let publicKey = await this.EcdhConvertKey(b64Public);\n    \n    let privateKey = await this.EcdhConvertKey(b64Private);\n    \n    let salt = this.base64ToArray(b64Salt);\n    let iv = this.base64ToArray(b64iv);\n    let data = this.base64ToArray(b64data);\n    \n    \n    // 2.) generate shared secret for HKDF\n    //\n    let sharedSecret = await this.#crypto.subtle.deriveBits({ \n      \"name\": \"ECDH\", \n      \"namedCurve\": \"P-256\", \n      \"public\": publicKey \n    },privateKey,256);\n    \n    // 3.) convert shared-secret into a key\n    //\n    let sharedSecretKey = await this.#crypto.subtle.importKey(\n      \"raw\", sharedSecret, \n      { \"name\": 'HKDF' }, \n      false, \n      ['deriveKey','deriveBits']\n    );\n    \n    // 4.) convert the live-shared-secret-key into an aes key\n    //\n    let derivedKey = await this.#crypto.subtle.deriveBits({\n      \"name\": 'HKDF', \n      \"hash\": 'SHA-256', \n      \"salt\": salt,\n      \"info\": new Uint8Array([])},\n      sharedSecretKey,256\n    );\n\n    //\n    // 5.) \n    //     Convert the Key-Array to a live Key\n    let aes_key = await this.#crypto.subtle.importKey(\n      \"raw\",\n      derivedKey,\n      \"AES-GCM\",\n      false,\n      [\"encrypt\",\"decrypt\"]\n    );\n\n    // 6.) decrypt our data\n    //\n    let aes_data;\n    try{\n        aes_data = await this.#crypto.subtle.decrypt(\n        { name: \"AES-GCM\", iv: iv },\n        aes_key,\n        data\n      );\n    } catch(e){\n      console.log({name: e.name, stack: e.stack, message: e.message});\n    }\n\n    return aes_data;\n\n  };\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcMakeSigKeys (async)\n  // What is this: Given\n  //\n  // Arguments:    none\n  //\n  // Returns:      object containing public and private key pair\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  \n  EcMakeSigKeys = async (exportable = true) => {\n    await this.#sleep(0);\n\n  // Step 1) Create ECDSA KeyS\n    let keys = await this.#crypto.subtle.generateKey(\n      { name: \"ECDSA\", namedCurve: \"P-256\" },\n      exportable,\n      [\"sign\",\"verify\"]\n    );\n    \n    let b64Keys;\n\n  // Step 2a) IF EXTRACTABLE: Export keys to SPKI|PKCS8 format\n    if(exportable){\n      b64Keys = await Promise.all([\n        this.#crypto.subtle.exportKey(\"spki\", keys.publicKey).then((key) => {\n          return this.arrayToBase64(new Uint8Array(key));\n        }),\n        this.#crypto.subtle.exportKey(\"pkcs8\", keys.privateKey).then((key) => {\n          return this.arrayToBase64(new Uint8Array(key));\n        })\n      ]);\n      \n      return { publicKey: b64Keys[0], privateKey: b64Keys[1] };\n\n    } else {\n      \n  // Step 2b) NOT NOT NOT EXTRACTABLE: Export just the public key\n      b64Keys = await Promise.all([\n        this.#crypto.subtle.exportKey(\"spki\", keys.publicKey).then((key) => {\n          return this.arrayToBase64(new Uint8Array(key));\n        })\n      ]);\n      return { publicKey: b64Keys[0], privateKey: keys.privateKey };\n    }\n\n  };\n  \n  \n  \n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcSignData (async)\n  // What is this: Create a crypto-signature from a private key and data\n  //\n  // Arguments:    base64privateKey: string;\n  //               data: Uint8Array;\n  //\n  // Returns:      base64 encoded signature\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  EcSignData = async (b64PrivateKey, b64data) => {\n    await this.#sleep(0);\n\n    // 1.) convert the given keys to real keys\n    let privateKey = await this.EcdsaConvertKey(b64PrivateKey);\n\n    // 2.) sign the data with the live key\n    let signature = await this.#crypto.subtle.sign({\"name\": \"ECDSA\", \"hash\": {\"name\": \"SHA-256\"}}, privateKey, this.base64ToArray(b64data));\n\n    // 3.) Base64 and return our data...\n    return  await this.arrayToBase64(new Uint8Array(signature));\n  \n  };\n  \n  \n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcVerifySig (async)\n  // What is this: Given a public key, some data, and a signature; prove the\n  //               signature came from the data and the public key\n  //\n  // Arguments:    base64PublicKey: string;\n  //               data: Uint8Array;\n  //\n  // Returns:      base64 encoded signature\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n  EcVerifySig = async (b64PublicKey, b64Signature, b64data) => {\n    await this.#sleep(0);\n\n    // 1.) convert the given keys to real keys\n    let publicKey = await this.EcdsaConvertKey(b64PublicKey);\n    \n\n    // 2.) Convert the signature to an array\n    let signature = this.base64ToArray(b64Signature);\n\n    // 3.) verify the data with the live key\n    return await this.#crypto.subtle.verify({\"name\": \"ECDSA\", \"hash\": {\"name\": \"SHA-256\"}}, publicKey, signature, this.base64ToArray(b64data));\n\n  };\n  \n  \n  \n  \n  \n  \n  \n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EzConvertKey (base64key)\n  // What is this: Sloppy AF function to try converting random data into a key\n  //               until something works...\n  //\n  // Arguments:    none\n  //\n  // Returns:      hopefully a live key...probably an error and an hour of debugging.\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  \n  \n  \n  EcdhConvertKey = async (unknown_key) => {\n    await this.#sleep(0);\n\n    let key;\n    let longKey;\n    \n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // NATURAL KEY\n    if(unknown_key instanceof this.#crypto.CryptoKey){\n      return unknown_key;\n    }\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // SPKI PUBLIC?\n    //\n    //\n    try {\n      key = await this.#crypto.subtle.importKey(\n        \"spki\",\n        this.base64ToArray(unknown_key),\n        { name: \"ECDH\", namedCurve: \"P-256\" },\n        true,\n        []\n      );\n      return key;\n\n    } catch(e){}\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // RAW PUBLIC\n    //\n    //\n    try {\n      key = await this.#crypto.subtle.importKey(\n        \"raw\",\n        this.base64ToArray(unknown_key),\n        { name: \"ECDH\", namedCurve: \"P-256\" },\n        true,\n        []\n      );\n      return key;\n      \n    } catch(e){}\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // PKCS8 PRIVATE\n    //\n    //\n    try{\n      key = await this.#crypto.subtle.importKey(\n        \"pkcs8\",\n        this.base64ToArray(unknown_key),\n        { name: \"ECDH\", namedCurve: \"P-256\" },\n        false,\n        [\"deriveKey\",\"deriveBits\"]\n      );\n      return key;\n      \n    } catch(e){}\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // RAW PUBLIC - PERVERTED\n    //\n    //\n    try {\n      \n      longKey = new Uint8Array([4].concat(Array.from(this.base64ToArray(unknown_key))));\n      key = await this.#crypto.subtle.importKey(\n        \"raw\",\n        longKey,\n        { name: \"ECDH\", namedCurve: \"P-256\" },\n        true,\n        []\n      );\n      return key;\n      \n    } catch(e){\n      throw new Error(\"UNRECOGNIZED KEY FORMAT\");\n    }\n\n\n\n  }\n\n\n\n\n  // //////////////////////////////////////////////////////////////////////////\n  // //////////////////////////////////////////////////////////////////////////\n  //\n  // Function:     EcdsaConvertKey (some sort of key)\n  // What is this: Sloppy AF function to try converting random data into a key\n  //               until something works...\n  //\n  // Arguments:    none\n  //\n  // Returns:      hopefully a live key...probably an error and an hour of debugging.\n  // Notes:\n  //\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n  \n  EcdsaConvertKey = async (unknown_key) => {\n    await this.#sleep(0);\n\n    let key;\n    let longKey;\n    let err = true;\n    \n    \n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // NATURAL KEY\n    if(unknown_key instanceof this.#crypto.CryptoKey){\n      return unknown_key;\n    }\n    \n    \n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // SPKI PUBLIC?\n    //\n    //\n    try {\n      \n      key = await this.#crypto.subtle.importKey(\n        \"spki\",\n        this.base64ToArray(unknown_key),\n        { name: \"ECDSA\", namedCurve: \"P-256\" },\n        true,\n        [\"verify\"]\n      );\n      \n      return key;\n      \n    } catch(e){}\n\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // RAW PUBLIC\n    //\n    //\n    try {\n      \n      key = await this.#crypto.subtle.importKey(\n        \"raw\",\n        this.base64ToArray(unknown_key),\n        { name: \"ECDSA\", namedCurve: \"P-256\" },\n        true,\n        [\"verify\"]\n      );\n\n      return key;\n      \n    } catch(e){}\n\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // PKCS8 PRIVATE\n    //\n    //\n    try{\n\n      key = await this.#crypto.subtle.importKey(\n        \"pkcs8\",\n        this.base64ToArray(unknown_key),\n        { name: \"ECDSA\", namedCurve: \"P-256\" },\n        false,\n        [\"sign\"]\n      );\n\n      return key;\n      \n    } catch(e){}\n\n    //\n    //\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    // RAW PUBLIC - PERVERTED\n    //\n    //\n    try {\n\n      longKey = new Uint8Array([4].concat(Array.from(this.base64ToArray(unknown_key))));\n      key = await this.#crypto.subtle.importKey(\n        \"raw\",\n        longKey,\n        { name: \"ECDSA\", namedCurve: \"P-256\" },\n        true,\n        [\"sign\"]\n      );\n\n      return key;\n      \n    } catch(e){\n      throw new Error(\"UNRECOGNIZED KEY FORMAT\");\n    }\n\n  }\n\n  \n  \n}\n// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\","import EZCrypto from 'ezcrypto';\r\n// ////////////////////////////////////////////////////////////////////////////\r\n// ////////////////////////////////////////////////////////////////////////////\r\n// ////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Class with methods to interract with APEX\r\n//\r\nexport default class WebAPEX {\r\n  //\r\n  // Private Class Variables\r\n  //\r\n  #socket; // Our WebSocket\r\n  #radio; // Quick-and-Dirty PUB/SUB\r\n  #socketURL; // This is the URL our websocket hits\r\n  #iterator = 1; // Functional placeholder: This is the number of times\r\n  // we've sent data through the websocket\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // Function:     constructor\r\n  // What is this: class initiation methods and creation of QR iFrame\r\n  //\r\n  // Arguments:    socketURL: (string) - URL of the APEX WebSocket\r\n  //               keyriURL: (string) - URL of Keyri API\r\n  //               targetElement: (DOMElement) - this is what we are putting iframe in\r\n  //\r\n  // Returns:      an instance of WebAPEX\r\n  // Notes:\r\n  //\r\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n\r\n  constructor(socketURL, targetElement) {\r\n    // This allows us to issue custom events\r\n    // that a class user can listen to\r\n    //\r\n    this.#radio = document.createDocumentFragment();\r\n    this.#socketURL = socketURL;\r\n\r\n\r\n\r\n\r\n    const iframeSrc = `\r\n    <!DOCTYPE html>\r\n    <html lang=\"en-US\">\r\n      <head>\r\n        <meta charset=\"UTF-8\" />\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n        <link href=\"https://static.keyri.com/library-keyri-connect/iframe.css\" rel=\"stylesheet\">\r\n      </head>\r\n      <body>\r\n        <div class=\"pre-blurry\" id=\"qr-target\" style=\"height: 100%; width: 100%; z-index: -1\" ></div>\r\n        <div\r\n          id=\"qr-lay-over\"\r\n          onclick=\"main();\"\r\n          style=\"height: 100%; width: 100%; position: absolute; top: 0; left: 0; z-index: 1\"\r\n        ></div>\r\n      </body>\r\n    </html>\r\n    \r\n    <script>\r\n\r\n        const postMessage = window.parent.postMessage;\r\n        postMessage(\"HI MOM\",\"*\");\r\n\r\n        top = {location: {}}\r\n        self = {location: {host: top.location.host}};\r\n        parent = {location: {origin: location.origin}};\r\n        \r\n        window.parent.postMessage = (a,b) => {\r\n          console.log(\"POST-MESSAGE\",{a,b});\r\n          return postMessage(a,\"*\")\r\n        }\r\n\r\n        postMessage(\"WAIT UNTIL THEY GET A LOAD OF ME...\",\"*\");\r\n\r\n    \r\n    </script>\r\n\r\n    <script src=\"https://static.keyri.com/library-keyri-connect/keyri-0.10.3.dev.min.js\"></script>\r\n    `;\r\n\r\n    window.addEventListener(\"message\", this.handlePost, false);\r\n    // Creating iframe and configure it\r\n    const keyriQR = document.createElement(\"iframe\");\r\n    keyriQR.srcdoc = iframeSrc;\r\n    keyriQR.style.padding = \"50px\";\r\n    keyriQR.style.width = \"350px\";\r\n    keyriQR.style.height = \"350px\";\r\n    keyriQR.style.borderWidth = \"0\";\r\n    keyriQR.style[\"vertical-align\"] = \"middle\";\r\n    keyriQR.style.borderWidth = \"0\";\r\n    keyriQR.scrolling = \"no\";\r\n\r\n    // Load the iframe onto our target\r\n    targetElement.innerHTML = \"\";\r\n    targetElement.appendChild(keyriQR);\r\n  }\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     connect (async)\r\n  //\r\n  // SCOPE:        Public\r\n  //\r\n  // PURPOSE:      Method for creating a private websocket connection with APEX, and setting up event\r\n  //               handlers\r\n  //\r\n  // ARGS:         socketURL: (string) - URL Where the websocket is connecting\r\n  //\r\n  // RETURNS:      event data from the socket's \"onopen\" method - so you know you're connected\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  connect = async () => {\r\n\r\n    console.log(\"RUNNING CONNECT\");\r\n    // Try creating a websocket, and connecting\r\n    // it to the socketURL. Return the error if\r\n    // it bombs out...\r\n    //\r\n    //try{\r\n    this.#socket = new WebSocket(this.#socketURL);\r\n\r\n    //\r\n    // This promise makes the method async...\r\n    // We're connecting above...\r\n    // We resolve the following promise once the\r\n    // socket's `onopen` is triggered\r\n    //\r\n    return new Promise((resolve, reject) => {\r\n      // Once we catch an 'onopen' event; resolve the promise\r\n      this.#socket.onopen = (event) => {\r\n        resolve(event);\r\n      };\r\n\r\n      // Listen for a message, broadcast a custom event\r\n      // to the \"i\" in the response MINO\r\n      this.#socket.onmessage = (message) => {\r\n\r\n        console.log(\"CONNECT METHOD\",{message});\r\n\r\n        let eMsg = JSON.parse(message.data);\r\n\r\n        eMsg.o = JSON.parse(eMsg.o);\r\n\r\n        let id = eMsg.i;\r\n\r\n        this.#broadcast(id.toString(), eMsg);\r\n      }\r\n\r\n\r\n      // Add a one time event listener for errors from the socket\r\n      this.#socket.addEventListener(\r\n        \"error\",\r\n        (err) => {\r\n          this.#broadcast(\"error\", err);\r\n          reject(err);\r\n        });\r\n\r\n      // Set a timeout to blow up after 5 seconds;\r\n      // if it goes off; reject the promise\r\n      setTimeout(() => {\r\n        reject(new Error(\"WS connect attempt timed out...\"));\r\n      }, 5_000);\r\n    });\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     send (async)\r\n  //\r\n  // SCOPE:        Public\r\n  //\r\n  // PURPOSE:      Public Method to send arbitrary data over the web-socket\r\n  //               and wait for response...\r\n  //\r\n  // ARGS:         data: (string) - whatever you're sending across the wire\r\n  //\r\n  // RETURNS:      event data from the socket's \"onmessage\" method\r\n  //\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  send = async (data) => {\r\n    // Keep track of the iterator by adding 2 every time (our i's will be odd)\r\n    this.#iterator += 2;\r\n\r\n    // https://stackoverflow.com/questions/58030661/promisify-event-based-pattern\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // Figure out what custom call we're listening for...\r\n      let iterator = JSON.parse(data).i;\r\n\r\n      // Add a one time event listener for custom events of type `iterator`\r\n      this.on(iterator.toString(),(evnt) => {\r\n\r\n          // 0.) Pull data from event\r\n          let eData = evnt.detail;\r\n\r\n          // 1.) See if the object \"o\" has an `errormsg`. If so throw an error.\r\n          if (typeof eData.o.errormsg == \"string\") {\r\n            this.#broadcast(\"error\", eData);\r\n            reject(eData);\r\n            return false;\r\n          } else {\r\n            resolve(eData);\r\n          }\r\n\r\n        });\r\n\r\n\r\n      // //////////////////////////////////////////////////////////////////////\r\n      // Now that listeners are set up; send data to websocket api\r\n      // //////////////////////////////////////////////////////////////////////\r\n      this.#socket.send(data);\r\n\r\n      // //////////////////////////////////////////////////////////////////////\r\n      // To ensure that this doesn't hang forever, wait at most 5 seconds;\r\n      // then reject the whole thing\r\n      // //////////////////////////////////////////////////////////////////////\r\n      setTimeout(() => {\r\n        reject(new Error(\"WS send attempt timed out...\"));\r\n      }, 5_000);\r\n    });\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     authUser (async)\r\n  //\r\n  // SCOPE:        Public\r\n  //\r\n  // PURPOSE:      Public Method to send/receive authentication data\r\n  //               from APEX API\r\n  //\r\n  // ARGS:         APIKey: (string) - given at account signup\r\n  //               APISecret: (string) - given at account signup\r\n  //               UserId: (string) - given at account signup\r\n  //\r\n  // RETURNS:      whatever the API returns (todo - give better info HERE)\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  authUser = async (APIKey, APISecret, UserId) => {\r\n    // Create a nonce and signature per APEX API Requirements\r\n    let Nonce = window.crypto\r\n      .getRandomValues(new Uint8Array(32))\r\n      .join(\"\")\r\n      .substring(0, 13);\r\n    let Signature = await EZCrypto.hmac(\r\n      APISecret,\r\n      `${Nonce}${UserId}${APIKey}`\r\n    );\r\n\r\n    // Create a credentials object\r\n    const creds = { Nonce, UserId, APIKey, Signature };\r\n\r\n    // Stringify and send it...\r\n    let payload = JSON.stringify({\r\n      m: 0,\r\n      i: this.#iterator,\r\n      n: \"AuthenticateUser\",\r\n      o: JSON.stringify(creds),\r\n    });\r\n\r\n    let data = await this.send(payload);\r\n\r\n    return data;\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     destroyAPIKey (async)\r\n  //\r\n  // SCOPE:        Public\r\n  //\r\n  // PURPOSE:      Public Method to DESTROY user's API Key ***AFTER***\r\n  //               they are logged in...\r\n  //\r\n  // ARGS:         APIKey: (string) - given at account signup\r\n  //               UserId: (string) - given at account signup\r\n  //\r\n  // RETURNS:      whatever the API returns (todo - give better info HERE)\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  destroyAPIKey = async (APIKey, UserId) => {\r\n    let payload = JSON.stringify({\r\n      m: 0,\r\n      i: this.#iterator,\r\n      n: \"RemoveUserAPIKey\",\r\n      o: JSON.stringify({ UserId: UserId, APIKey: APIKey }),\r\n    });\r\n\r\n    let data = await this.send(payload);\r\n\r\n    return data;\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     getAPIKeys (async)\r\n  //\r\n  // SCOPE:        Public\r\n  //\r\n  // PURPOSE:      Public Method to GET ALL API Keys ***AFTER***\r\n  //               they are logged in... (optional)\r\n  //\r\n  // ARGS:         UserId: (string) - given at account signup\r\n  //\r\n  // RETURNS:      APIKey Array Object\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  getAPIKeys = async (APIKey, UserId) => {\r\n    let payload = JSON.stringify({\r\n      m: 0,\r\n      i: this.#iterator,\r\n      n: \"GetUserAPIKeys\",\r\n      o: JSON.stringify({ UserId: UserId, APIKey: APIKey }),\r\n    });\r\n\r\n    let data = await this.send(payload);\r\n\r\n    return data;\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     on\r\n  //\r\n  // SCOPE:        Public\r\n  //\r\n  // PURPOSE:      exposes a way for a user to listen to events that the class\r\n  //               emits. SUPER USEFUL FOR ERROR HANDLING...!\r\n  //\r\n  //\r\n  //\r\n  // ARGS:         eventType: (string) - what is the name of the event you're\r\n  //                          listening for?\r\n  //\r\n  //               eventHandler: (function) - what do you want to do\r\n  //\r\n  // RETURNS:      whatever the API returns (todo - give better info HERE)\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  on = (eventType, eventHandler) => {\r\n    this.#radio.addEventListener(eventType, eventHandler);\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // FUNCTION:     broadcast\r\n  //\r\n  // SCOPE:        PRIVATE\r\n  //\r\n  // PURPOSE:      here's how we throw up events for external listeners to...\r\n  //               listen to.\r\n  //\r\n  //\r\n  //\r\n  // ARGS:         eventType: (string) - what is the name of the event you're\r\n  //                          listening for?\r\n  //\r\n  //               eventData: (object) - information you want to respond with\r\n  //                          to the event handler\r\n  //\r\n  // RETURNS:      whatever the API returns (todo - give better info HERE)\r\n  //\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  #broadcast = (eventType, eventData) => {\r\n    this.#radio.dispatchEvent(\r\n      new CustomEvent(eventType, { detail: eventData })\r\n    );\r\n  };\r\n\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  // //////////////////////////////////////////////////////////////////////////\r\n  //\r\n  // Function:     handlePost (private) (async)\r\n  // What is this: THIS IS WHAT COMES BACK FROM THE API THROUGH THE IFRAME!!!\r\n  //\r\n  // Arguments:    message: - data coming from iframe\r\n  //\r\n  // Returns:      nothing\r\n  // Notes:\r\n  //\r\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n  // \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n  //\r\n  handlePost = async (message) => {\r\n\r\n    console.log(\"HANDLE-POST\", {message});\r\n\r\n    // Check messages from iframe with required action\r\n    if (message?.data?.type === \"session_validate\") {\r\n   \r\n      let mobile_data = JSON.parse(message?.data?.data);\r\n      let mobile_data_payload = JSON.parse(mobile_data?.o);\r\n      let mobile_data_payload_token = mobile_data_payload.SessionToken;\r\n\r\n      localStorage.token = mobile_data_payload_token;\r\n\r\n      setTimeout(() => {\r\n        window.location.reload();\r\n      }, 100);\r\n    }\r\n  };\r\n}\r\n// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\r\n\r\n/*\r\n// 1.) Get an element off of the DOM you want to load our iFrame into\r\nlet targetElement = document.querySelector(\".login-form__container-right\");\r\nlet yourDomain = \"bitazza.com\";\r\n\r\n// 2.) These are the URLs that the class will need\r\nlet ApexSocketURL = `wss://apexapi.${yourDomain}/WSGateway`;\r\nlet KeyriURL = \"./KeyriQR.html\";\r\n\r\n\r\n// 3.) Instantiate the class\r\nlet webApex = new WebApex(ApexSocketURL, targetElement);\r\n\r\n// 4.) Try connecting\r\nawait webApex.connect();\r\n\r\n// 5.) Listen for errors IF you want to handle them\r\nwebApex.on(\"error\",(err) => {\r\n  console.log(\"ERROR DATA:\",err);\r\n})\r\n*/"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","EZCrypto","constructor","window","this","crypto","CryptoKey","async","getPrototypeOf","duration","Promise","s","j","setTimeout","base64ToArray","strng","Uint8Array","from","atob","c","charCodeAt","arrayToBase64","ary","btoa","String","fromCharCode","HMAC","secret","data","encoder","TextEncoder","encodedSecret","encode","encodedData","subtle","importKey","name","hash","sig","sign","b","Array","map","x","toString","slice","join","HASH","algo","len","outAry","digest","Math","min","length","max","i","AESMakeKey","exportable","generateKey","out","exportKey","AESImportKey","aes_key","buffer","base_64_key","base_64_data","base_64_nonce","nonce","getRandomValues","encrypted","encrypt","iv","ciphertext","base_64_cipher","returnText","decrypted","nonce_ary","cipher_ary","decrypt","TextDecoder","decode","EcMakeCryptKeys","exportKeys","keys","namedCurve","all","publicKey","then","privateKey","jwkPublicKey","jwkPrivateKey","rawPublicKey","rawPublicKeyLite","EcEncrypt","b64Private","b64Public","b64data","EcdhConvertKey","deriveKey","public","aes_key_raw","b64_aes_key","AESEncrypt","EcDecrypt","b64Nonce","HKDFEncrypt","sharedSecret","deriveBits","sharedSecretKey","salt","derivedKey","HKDFDecrypt","b64Salt","b64iv","aes_data","e","console","log","stack","message","EcMakeSigKeys","b64Keys","EcSignData","b64PrivateKey","EcdsaConvertKey","signature","EcVerifySig","b64PublicKey","b64Signature","verify","unknown_key","longKey","concat","Error","WebAPEX","socketURL","targetElement","document","createDocumentFragment","addEventListener","handlePost","keyriQR","createElement","srcdoc","style","padding","width","height","borderWidth","scrolling","innerHTML","appendChild","connect","WebSocket","resolve","reject","onopen","event","onmessage","eMsg","JSON","parse","id","err","send","iterator","on","evnt","eData","detail","errormsg","authUser","APIKey","APISecret","UserId","Nonce","substring","creds","Signature","hmac","payload","stringify","m","n","destroyAPIKey","getAPIKeys","eventType","eventHandler","eventData","dispatchEvent","CustomEvent","type","mobile_data","mobile_data_payload_token","SessionToken","localStorage","token","location","reload"],"sourceRoot":""}